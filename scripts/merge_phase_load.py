#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Script to merge multiple phase_load.log files.

- The input phase_load.log is generated by using script
poll_load_from_pdu.exp
- Use this script to generate an aggregated phase load file by merging multiple
phase_load logs from storage nodes and rocksdb nodes in disaggregated tests.

Usage: $0 phase_load_1.log phase_load_2.log ...

"""

from contextlib import ExitStack

import re
import os
import sys


def __locate_mins(array):
    locs = []
    min_value = []

    for idx, val in enumerate(array):
        if not val:
            continue

        if not min_value or val < min_value:
            min_value = val
            locs = [idx]
        elif val == min_value:
            locs.append(idx)

    return locs


def main():
    """Merge the content of multiple phase_load.log files to a single file."""
    output_log = 'phase_load.log'
    if os.path.isfile(output_log):
        print("[ERROR] Cannot write output to file phase_load.log in the \
current directory because it already exists." + os.linesep)
        exit(1)

    with open('phase_load.log', 'w') as fout:
        load_line_pattern = \
            re.compile(r'(\[\d{4}\-\d{2}-\d{2}\w+\d{2}:\d{2}:\d{2}.+\]) (.+)')

        # Open a variable list of files using "with":
        # https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack
        with ExitStack() as stack:
            logs = [stack.enter_context(open(fname, 'rt'))
                    for fname in PHASE_LOAD_FILES]

            results = [None] * len(logs)

            while True:
                for idx, log in enumerate(logs):
                    while not results[idx]:
                        line = log.readline()
                        if not line:
                            break
                        results[idx] = load_line_pattern.match(line)

                if not any(results):
                    break

                min_idxes = __locate_mins(
                    [match.group(1) if match else None for match in results])
                timestamp = results[min_idxes[0]].group(1)
                sum_value = 0
                for idx in min_idxes:
                    sum_value += float(results[idx].group(2))
                    results[idx] = None

                fout.write(timestamp + ' ' + str(sum_value) + os.linesep)


if __name__ == "__main__":
    NUM_ARGS = len(sys.argv)
    if NUM_ARGS < 3:
        print("""\
Usage: {} phase_load.log ...

phase_load.log:
    The log file generated by script poll_load_from_pdu.exp
""".format(sys.argv[0]))
        exit(1)

    PHASE_LOAD_FILES = sys.argv[1:]
    main()
